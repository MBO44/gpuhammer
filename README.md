# GPU-RowHammer (34th USENIX Security Symposium)

## Introduction

This is the code artifact for the paper 
**"GPUHammer: Rowhammer Attacks on GPU Memories are Practical"**, presented at [USENIX Security 2025](https://www.usenix.org/conference/usenixsecurity25)

Authors: Chris S. Lin (University of Toronto), Joyce Qu (University of Toronto), Gururaj Saileshwar (University of Toronto).

## Required Environment
**Run-time Environment:**  We suggest using a Linux distribution compatible with g++-11 or newer. We tested our artifacts on Ubuntu 20.04.

- Software Dependencies:
   - Anaconda 24.9.2
   - CMake 3.26.4+
   - g++ with C++17 Support (tested with 11.4.90)
   - Python 3.10+
   - NVIDIA CUDA Driver (Tested with Driver Version: 545.23.08)
   - NVIDIA CUDA Toolkit (Tested with CUDA Version: 12.3)

- Hardware Dependencies:
   - NVIDIA GPU sm_80+

## Affected GPUs
- NVIDIA A6000 GPU with 48GB GDDR6

## Steps for Artifact Evaluation

### 1. Clone the Repository
Ensure you have already cloned the repository:
```bash
git clone https://github.com/sith-lab/gpuhammer.git
cd gpuhammer
```

## 2. GPU Setup
For the Rowhammer attack, a prerequiste is having **ECC disabled**. This is already the default setting on many GPUs. But if it is enabled, use the following commands to disable it:
```bash
sudo nvidia-smi -e 0
rmmod nvidia_drm 
rmmod nvidia_modeset
sudo reboot
```

 Our profiling is easier with the persistence mode enabled, and with fixed GPU and memory clock rates, although these are not pre-requisites. The following script performs the above actions:
```bash
# Example usage: 
#   bash ./util/init_cuda.sh 1800 7600
bash ./util/init_cuda.sh <MAX_GPU_CLOCK> <MAX_MEMORY_CLOCK>
```

**MAX_GPU_CLOCK** and **MAX_MEMORY_CLOCK** are found with `deviceQuery` from CUDA samples, which we provide a sample for A6000 in 'deviceQuery.txt'. 

To undo the changes, run:
```bash
bash ./util/reset_cuda.sh
```

### 3. Run the Artifact
Run the following commands to install dependencies, build GPUHammer, and execute experiments.

```bash
  cd gpuhammer # Ensure you are in the respository root
  export HAMMER_ROOT=`pwd`
  bash ./run_artifact.sh
```

### 4. Generate Figures
After completing the experiments, use the command below to generate plots.

```bash
bash ./plot_all_figures.sh
```

## Detailed Steps for Artifacts

### Prerequisites
Install RAPIDS RMM and Python dependencies.

```bash
bash ./run_setup.sh
```

If error occurs during setup, run the following to clean up left-over artifacts.

```bash
bash ./run_setup.sh clean
```

### Enable Anaconda RMM Development Environment
You need to enable the RMM development manually when opening a terminal.

```bash
conda init
source activate base
conda activate rmm_dev
```

### Building GPUHammer
Create the build environment using CMake:

```bash
cmake -S ./src -B ./src/out/build
cd ./src/out/build
make
```

### Run experiments

#### Row/Conflict Sets (5 Random Banks)

```bash
bash run_row_sets.sh
```

#### Figure 2

```bash
bash run_fig2.sh
```

#### Figure 5 & 6

```bash
bash run_fig5_6.sh
```

#### Figure 8

```bash
bash run_fig8.sh
```

#### Figure 10

```bash
bash run_fig10.sh
```

#### Figure 11

```bash
bash run_fig11.sh
```

#### Figure 12

```bash
bash run_fig12.sh
```

#### Figure 13 & Table 4

```bash
bash run_fig13_t4.sh
```

#### Figure 15

```bash
bash run_fig15.sh
```

#### Figure 16

```bash
bash run_fig16.sh
```

### Generate Plots

After running the experiments, generate the plots in using the commands below. Generated PDFs can be found in respective folders: `./results/plots/fig*`.

#### Figure 2:

```bash
cd plot_scripts
python3 plot_fig2.py
```

#### Figure 5:

```bash
python3 plot_fig5a.py
python3 plot_fig5b.py
```

#### Figure 6:

```bash
python3 plot_fig6.py
```

#### Figure 8:

```bash
python3 plot_fig8.py
```

#### Figure 10:

```bash
python3 plot_fig10a.py
python3 plot_fig10b.py
```

#### Figure 11:

```bash
python3 plot_fig11.py
```

#### Figure 12:

```bash
python3 plot_fig12.py
```

#### Figure 13:

```bash
python3 plot_fig13.py
```

#### Table 4:

```bash
bash plot_t4.sh
```

#### Figure 15:

```bash
python3 plot_fig15.py
```

#### Figure 16:

```bash
python3 plot_fig16.py
```
## Detailed Steps to Run Rowhammer Campagin & Exploit

### Step 1: Obtain Row Addresses to Hammer

In the repository `util` folder, you can find the `run_timing_task.py` script containing the relevant toolings to generate the Row Set of a bank:

```python
# Display available tasks available for row buffer conflict
python3 ./util/run_timing_task.py -h

# Display usage to the specific task
python3 ./util/run_timing_task.py <task> -h
```

#### Workflow

**1. Identify tRC:** Get a rough idea of the **tRC** (time between two row activations) with the output of `gt` task. After inspecting the file you should be able to observe the difference in latency between row-buffer hits and conflicts. By default, the result is stored in a text `TIME_VALUE.txt` generated by the script. For example, here, we observe tRC is **~43**.
   -  ```
      python3 ./util/run_timing_task.py gt
      ```
   -  ```
      ...

      328
      336
      327
      338
      360
      360
      ```

**2. Generate Conflict Set:** Obtain a **Conflict Set** with the output of `conf_set` task
Conflict set is a list of array offsets (addresses) that map to rows that conflict with the row of a fixed address (reference). By default, the result is stored in a text `CONF_SET.txt` generated by the script.

**NOTE**: When selecting the conflict threshold, due to noise, pick a number lower than the observed **tRC** for better accuracy. We observe on A6000 that values around 25-30ns works well. 

   -  ```bash
      python3 ./util/run_timing_task.py conf_set \
      --threshold 27 \
      --step 256 \
      --it 15
      ```
   -  ```
      852224
      852736
      868352
      868864
      895232
      895744
      911360
      911872
      ```

**3. Generate Row Set:** Obtain the **Row Set** for the bank corresponding to step 2 with the output of `row_set` task. 

Row Set is a matrix of offsets, where each line lists the address offsets mapping to the same DRAM row. By picking one adddress from each line, we can map to unique rows in the DRAM bank. By default, the result is stored in a text `ROW_SET.txt` generated by the script.

   -  ```bash
      python3 ./util/run_timing_task.py row_set CONF_SET.txt \
      --threshold 27 \
      --it 15
      ```
   -  ```
        852224	852736	868352  ...
        1153280	1153792	1169408  ...
        ...
      ```

**(Optionally) 4. Bank Set:** Obtain a **Bank Set** with the output of `bank_set` task. Bank Set has the offsets that correspond to different banks in the GPU. It is recommended that you add a large _size_ and test a small _max_ at first, as the number of banks is undecidable for this program. By default, the result is stored in a text `BANK_SET.txt` generated by the script.

   -  ```bash
      python3 ./util/run_timing_task.py bank_set \
      --threshold 27 \
      --max 5 \
      --step 256 \
      --it 15
      ```
   -  ```
      0
      256
      1024
      1280
      2048
      ```

### Step 2: Observe Correct Delay for Alignment
This step helps to obtain the exact delay to be added to synchronize the aggressor pattern with DRAM REF commands. A helpful script, `run_delay.sh`, is available in the `util` folder. We assume the row set files are stored at `./results/row_sets/ROW_SET_<bank_id>.txt`, and the hammering results is dumped in `./src/log/`. Please update the relevant variables in the script, specifically the `bank_id` and file locations. You can run the script with:

```bash
bash ./util/run_delay.sh
```

You can visualize the result by running 
```bash
# Example usage:
#  python3 ./util/plot_delay.py 10000 1407 256 24
python3 ./util/plot_delay.py <iterations> <trefi> <bank_id> <num_aggressors>
```

The first parameter is the number of iterations, which should match the `iterations` variable in the bash script. The second parameter is the tREFI period in nanoseconds, which is 1407 for the A6000. The fourth and onward parameters specify the number of aggressors. You can plot multiple aggressor configurations on the same plot.

On the output plot, observe that there is a flat-lined area in the middle. This is where synchronization occurs, and the delays in that area are optimal.

### Step 3: Profile for Bit-flips

The helper script `run_hammer.sh` is available in the `util` folder. Again, we assume a file structure for the row set files and log files, so please update the relevant variables. In addition, fill in the `delay` configuration you obtained from the previous step. You can run the script with

```bash
sudo bash ./util/run_hammer.sh
```

The result of your hammering can be found at `./src/log/sweep/<#_of_aggressors>agg_b<bank_id>_<vic_pat><agg_pat>.log`. Any bitflips will be reported in the form `Observed Bit-Flip ...` in the log file.

### Campaign Configurations

In our systematic study, we ran attacks with `num_agg = 8, 12, 16, 20, 24` and `skip_step = 3`. We launched campaigns with both gridded victim data patterns. (`vic_pat=55, agg_pat=aa` and `vic_pat=aa, agg_pat=55` ) For each configuration, we used the following setups:
- **8-sided**: 8 warps, 1 thread, 3 rounds
- **12-sided**: 6 warps, 2 threads, 2 rounds
- **16-sided**: 8 warps, 2 threads, 1 round
- **20-sided**: 10 warps, 2 threads, 1 round
- **24-sided**: 8 warps, 3 threads, 1 round

Each hammer takes approximately 600 ms to run if we treat the entire bank as victim rows. Alternatively, to speed up the hammers, you can comment and uncomment some code according to line 110 & 111 of `./src/hammer/gpu_hammer.cu`. This verifies only the rows in the neighborhood of the hammered aggressors for bitflips, reducing the time for a hammer kernel to around 200 ms. With this setup, it takes approximately 5 hours to complete a sweep on one bank with a single `num_agg` configuration for both data patterns.

#### Existing Bitflips

Reproducing bitflips from our A6000 can be done with `./util/run_known_flips.sh`. You can find the bitflip results in the folder `./results/sample_bitflips`.

```bash
sudo bash ./util/run_known_flips.sh
```

### Step 4: Perform Time Sliced Exploit

Once you have found some **0->1** bit-flips that maps to the Most Significant Bit in FP16, you can run an exploit, targeting these bit-flips in a ML model weight. We provde sample exploit scripts `run_hammer_manual_<bitflip>.sh` in `data_scripts/fig12_t4` that streamline the process. 

#### Finding the Proper Aggressor Row for Victim Row

When a bit-flip is observed, as shown in the paper, it can only be trigger by aggressor rows on one side. Once you have observed a set of aggressors (As) that triggers the bitflip in a victim (V), usually in the form of:

```
... A - - - A - V - A - - - A ...
```

You can find out which aggressor triggered it by shifting the pattern by changing `min_rowid`:

```
Left Aggressor:   ... A - - - A - V
Right Aggressor:  V - A - - - A ...
```

#### Aggressor on the Left/Top of Victim

To exploit given a left side aggressor, we can create a script based on either the `run_hammer_manual_B1.sh` or `run_hammer_manual_D1.sh`. You will need to modify the following parameters based on information of your observed bitflip.

- **aggressor_row:** Row id of the aggressor row left of the victim.
- **victim_row:** Row id of the victim.
- **victim_row_offset:** Offset of the victim row in Row Set. (Note Row id starts at 0, but Row Set text file line number may read starting line 1)
- **aggressor_row_offset:** Offset of the aggressor row in Row Set. (Note Row id starts at 0, but Row Set text file line number may read starting line 1)
- **store_dir:** Location to store your exploit results.

```bash
bash ./data_scripts/fig12_t4/run_hammer_manual_<name>.sh
```

You may find the results of your exploits in your `store_dir`, listed in `<model>.txt`.

#### Aggressor on the Right/Bottom of Victim

To exploit given a right side aggressor, we can create a script based on either the `run_hammer_manual_B2.sh` or `run_hammer_manual_D3.sh`. You will need to modify the following parameters based on information of your observed bitflip. The parameters are slightly different than what you have for left side:

- **aggressor_row:** Row id of the aggressor row left of the victim.
- **victim_byte_offset:** The exact byte offset of the bitflip.
- **aggressor_row_offset:** Offset of the aggressor row in Row Set. (Note Row id starts at 0, but Row Set text file line number may read starting line 1)
- **store_dir:** Location to store your exploit results.

```bash
bash ./data_scripts/fig12_t4/run_hammer_manual_<name>.sh
```

You may find the results of your exploits in your `store_dir`, listed in `<model>.txt`.

#### Exploit with Existing Bitflips

The scripts in `./data_scripts/fig12_t4` will run the exploit on ImageNet models with specific bitflips we found in our A6000 GPU (B1, B2, D1, and D3). The model accuracy will be recorded in `./results/fig12_t4/<bitflip>`.

```bash
bash ./data_scripts/fig12_t4/run_hammer_manual_<bitflip>.sh
```

This entire exploit with all the bit-flips should take 1 day.

## Additional Notes

### Clock Rate Note
The clock rate output by the console is always the maximum clock rate. Set the lgc value in init_cuda to >= maximum clock rate and the GPU will adjust to maximum clock rate.

### Compiler Settings Note
The most stable compiler setting is this, which disables all GPU kernel optimizations. **Xcicc** are the frontend pipelines and **Xptxas** are the backend pipelines (hence PTX). 
   ```cmake 
   set(CMAKE_CUDA_FLAGS "${CMAKE_CUDA_FLAGS} --generate-line-info -O3 -Xcicc -O0 -Xptxas -O0")
   ```
This is the setting that gives the lowest latency while not optimizing away our memory accesses. **Xptxas** gives the most performance increase since we are mostly using PTX and register allocation is our biggest concern. Turning either one past **O3** on its own will not optimize the access away, but with the other one past **O2**, it will be gone. They must have some mechanism at work collaborating the two, but it is not a major concern to us. 
   ```cmake 
   set(CMAKE_CUDA_FLAGS "${CMAKE_CUDA_FLAGS} --generate-line-info -O3 -Xcicc -O1 -Xptxas -O3")
   ```

## Happy Hammering :)


